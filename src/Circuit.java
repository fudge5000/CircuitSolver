import Jama.*;
import java.util.ArrayList;

/**
 * Represents an electric circuit
 * @author Jacob Oakman
 * @version 2018.10.01
 */
public class Circuit
{
    private ArrayList<Node> nodeList = new ArrayList<Node>();
    private ArrayList<Net> netList = new ArrayList<Net>();
    
    /**
     * Create a Circuit object
     * @param nodeList list of populated nodes
     */
    public Circuit()
    {
        //Do nothing
    }
    
    /**
     * Create a Circuit object
     * @param netlist list of electric components as nets
     */
    public Circuit(ArrayList<Net> netList)
    {
        this.netList = netList;
        this.generateNodeList();
    }
    
    public void generateNodeList()
    {
        Net curNet;
        ElectricComponent component;
        int nodeIndex;
        
        for (int i = 0; i < this.netList.size(); i++)
        {
            curNet = this.netList.get(0);
            
            switch (curNet.getComponentType())
            {
                case VOLTAGE_SOURCE: 
                {
                    component = new Source(SourceType.VOLTAGE, curNet.getValue());
                    break;
                }
                
                case CURRENT_SOURCE: 
                {
                    component = new Source(SourceType.CURRENT, curNet.getValue());
                    break;
                }
                
                case RESISTOR: 
                {
                    component = new Resistor(curNet.getValue());
                }
                
                default : {
                    component = new Resistor(curNet.getValue());
                }
            }
            
            for (int j = 0; j < 2; j++)
            {
                nodeIndex = curNet.getNodeIndexAt(j);
                
                if (nodeIndex > nodeList.size() || nodeList.get(nodeIndex) == null)
                {
                    nodeList.add(nodeIndex, new Node(nodeIndex));
                }
                
                nodeList.get(nodeIndex).addComponent(component);
                component.setNodeAt(j, nodeList.get(nodeIndex));
            }
        }
    }
    
    /**
     * Add a node to the circuit
     * @param node node to add
     * @return whether the node was added
     */
    public boolean addNode(Node node)
    {
        return this.nodeList.add(node);
    }
    
    /**
     * add node to the circuit at index
     * @param index
     * @param node
     */
    public void addNode(int index, Node node)
    {
        this.nodeList.add(index, node);
    }
    
    /**
     * Get node at position
     * @param index the index to get the node from
     * @return the node at index
     */
    public Node getNode(int index)
    {
        return this.nodeList.get(index);
    }
    
    /**
     * Solves the circuit using nodes
     */
    public void solveNode()
    {
        Equation[] matrix;
        
        matrix = this.getNodeKCLList();
        
        double[] nodeVoltageList = this.solveEquasions(matrix);
        
        for (int i = 0; i < nodeVoltageList.length; i++)
        {
            this.getNode(i+1).setVoltage(nodeVoltageList[i]);
        }
    }
    
    /**
     * Gets the node voltages for each node
     * @return an array with voltages for each node
     */
    public Equation[] getNodeKCLList()
    {
        Equation[] matrix = new Equation[nodeList.size()];
        
        for (int i = 0; i < nodeList.size(); i++)
        {
            matrix[i] = nodeList.get(i).generateNodeEquasion();
        }
        
        return matrix;
    }
    
    /**
     * Uses the arrays generated by the node equations
     * @param equasionList
     * @return array with voltages
     */
    public double[] solveEquasions(Equation[] equasionList)
    {
        double[][] coeficients = new double[equasionList.length][equasionList.length - 1];
        double[][] constants = new double[equasionList.length][1];
                
//        for (int y = 0; y < equasionList.length; y++)
//        {
//            for (int x = 1; x < equasionList[y].length; x++)
//            {
//                coeficients[y][x - 1] = equasionList[y][x];
//            }
//            constants[y][0] = equasionList[y][0];
//        }
        
        Matrix coefMatrix = new Matrix(coeficients);
        Matrix conMatrix = new Matrix(constants);
        
        return coefMatrix.solve(conMatrix).getColumnPackedCopy();
    }
}
